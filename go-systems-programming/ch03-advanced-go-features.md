[üîô Writing Programs in Go][previous-chapter]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[üè°][readme]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[Go Packages, Algorithms, and Data Structures üîú][upcoming-chapter]

# Chapter 3. Advanced Go Features

## Error Handling in Go

Errors happen so often, we need to catch and handle them, or get fired. Think about sensitive
system files, them going b0rk is not an option. Go has a data type called `error` that helps
signify erroneous states. If an `error` var has a `nil` val, there is no error.

You can ignore the `error` var like we saw before:

```go
temp, _ := strconv.Atoi(arguments[1])
```

This is not considered good practice, tho. For scrappy little scripts? Maybe. For something that 
will live on in infamy? Plz no.

In [File Input and Output (Chapter 6)][chapter-6], an `EOF` is a type of error that is returned
when there is nothing left to read from a file. An `EOF` is defined in the `io` pkg, so this 
works:

```go
if err == io.EOF {
  // do something
}
```

### Functions Can Return Error Vars

Go fns can return `error` vars, which means that an error condition can be handled inside a fn,
outside a fn, or both. So we will write a fn that returns error messages.

You can use `errors.New()` to create new `error` vars from strings. It's quite common to also do
a comparison against `nil` to see if the `error` var is an actual error or not.

When you log errors, you can `log.Fatal()` and it will automatically terminate your app. You have 
other options in the [`log` pkg][pkg/log] that are for less critical errors.

```go
package main

import (
  "errors"
  "fmt"
  "log"
)

// takes two points, and returns an int, error, & error
// returns an error if dividing by zero
// returns an error if a remainder exists
func division(x, y int) (int, error, error) {
  if y == 0 {
    // creates a new error variable - errors.New()
    return 0, nil, errors.New("Cannot divide by zero!")
  }
  if x%y != 0 {
    // creates a new error variable - errors.New()
    remainder := errors.New("There is a remainder!")
    return x / y, remainder, nil
  } else {
    return x / y, nil, nil
  }
}

func main() {
  result, rem, err := division(2, 2)
  if err != nil {
    log.Fatal(err)
  } else {
    fmt.Println("The result is", result)
  }

  if rem != nil {
    fmt.Println(rem)
  }

  result, rem, err = division(12, 5)
  if err != nil {
    log.Fatal(err)
  } else {
    fmt.Println("The result is", result)
  }

  if rem != nil {
    fmt.Println(rem)
  }

  result, rem, err = division(2, 0)
  if err != nil {
    log.Fatal(err)
  } else {
    fmt.Println("The result is", result)
  }

  if rem != nil {
    fmt.Println(rem)
  }
}
```

Executing the `funError.go` displays this output:

```
The result is 1
The result is 2
There is a remainder!
2018/03/31 23:10:14 Cannot divide by zero!
exit status 1
```

The last line? It is automatically generated by the `log.Fatal()` call.

### About Error Logging

Go offers fns that can help you log your error messages in various ways. Do use `log.Fatal()`
instead of `os.Exit()` so you can print an error message and exit your app in a single call.

Notable `log` methods from the [`log` pkg][pkg/log]:

* `log.Printf()`
* `log.Print()`
* `log.Println()`
* `log.Fatal()`
* `log.Fatalf()`
* `log.Fatalln()`
* `log.Panic()`
* `log.Panicln()`
* `log.Panicf()`

```go
//logging.go
package main

import (
  "log"
)

func main() {
  x := 1
  log.Printf("log.Print() function: %d", x)
  x = x + 1
  log.Printf("log.Print() function: %d", x)
  x = x + 1
  log.Panicf("log.Panicf() function: %d", x)
  x = x + 1
  log.Printf("log.Print() function: %d", x)
}
```

Notice the lack of the `mft` pkg because `log` has its own fns for printing the output.

Here's what you will see:

```
2018/03/31 23:19:16 log.Print() function: 1
2018/03/31 23:19:16 log.Print() function: 2
2018/03/31 23:19:16 log.Panicf() function: 3
panic: log.Panicf() function: 3

goroutine 1 [running]:
log.Panicf(0x10c5f52, 0x19, 0xc420047f48, 0x1, 0x1)
  /usr/local/Cellar/go/1.10/libexec/src/log/log.go:333 +0xda
main.main()
  /Users/jmills/go/src/go-systems-programming/logging.go:13 +0x18e
exit status 2
```

Although `log.Printf()` works like `fmt.Printf()`, it automatically prints the date and time the
log message was printed. `log.Panicf()` works like `log.Fatalf()`, except that it prints extra
info for debugging purposes.

There is even the [`log/syslog` pkg][pkg/log/syslog] that is a simple interface to the system
log service running on your Unix machine. [Working with System Files (Chapter 7)][chapter-7] will
talk more about it.

### The `addCLA.go` Program Revisisted

Let's update the `addCLA.go` program and call it `addCLAImproved.go`.

```go
package main

import (
  "fmt"
  "os"
  "strconv"
)

func main() {
  arguments := os.Args
  sum := 0
  for i := 1; i < len(arguments); i++ {
    // replaced the _ with an err var
    temp, err := strconv.Atoi(arguments[i])
    // if no err then it's valid
    if err == nil {
      sum = sum + temp
    } else {
      // invalid argument because err is not nil
      fmt.Println("Ignoring", arguments[i])
    }
    sum = sum + temp
  }
  fmt.Println("Sum:", sum)
}
```

Let's see what happens with this change:

```
$ go run addCLAImproved.go
Sum: 0
$ go run addCLAImproved.go 1 2 -3
Sum: 0
$ go run addCLAImproved.go 1 a 2 b 3.2 @
Ignoring a
Ignoring b
Ignoring 3.2
Ignoring @
Sum: 3
```

This is a better version because the user is informed of invalid arguments.

## Pattern Matching and Regular Expressions

**Grammar** is at the root of **regular expressions** (aka **pattern matching**, but not in the
_functional programming_ sense).

Let's use the [`regexp` pkg][pkg/regexp] to create `regExp.go`.

```go
package main

import (
  "fmt"
  "regexp"
)

func main() {
  // matches
  match, _ := regexp.MatchString("Mihalis", "Mihalis Tsoukalos")
  fmt.Println(match)
  // does not match, case-sensitive
  match, _ = regexp.MatchString("Tsoukalos", "Mihalis tsoukalos")
  fmt.Println(match)

  // validate the regex and return a usable regex.Regexp var
  // that can perform matches
  parse, err := regexp.Compile("[Mm]ihalis")

  if err != nil {
    fmt.Printf("Error compiling RE: %s\n", err)
  } else {
    fmt.Println(parse.MatchString("Mihalis Tsoukalos"))
    fmt.Println(parse.MatchString("mihalis Tsoukalos"))
    fmt.Println(parse.MatchString("M ihalis Tsoukalos"))

    // search the provided string ("mihalis Mihalis") for matches, and replace them with "MIHALIS"
    fmt.Println(parse.ReplaceAllString("mihalis Mihalis", "MIHALIS"))
  }
}
```

We use `regexp.Compile()` to read and validate a regex, and if it is a success, it returns a var
of the `regexp.Regexp` type that can be used later on.

Running `regExp.go` presents this output:

```
$ go run regExp.go
true
false
true
true
false
MIHALIS MIHALIS
```

### Printing All the Values From a Given Column of a Line

Super common scenario, like from a CSV or such. So, we'll look at `readColumn.go`, which prints
the third column.


```go
package main

import (
  "fmt"
  "strings"
)

func main() {
  // define an array of size 3
  var s [3]string

  // populate the array with space-separated values
  s[0] = "1 2 3"
  s[1] = "11 12 13 14 15 16"
  s[2] = "-1 2 -3 -4 -5 6"

  // define the column to read
  column := 2

  // go through each element of the array
  for i := 0; i < len(s); i++ {
    // split the string on whitespace characters
    data := strings.Fields(s[i])
    // if the data size has space for the relevant column
    if len(data) >= column {
      // print out the column
      fmt.Println((data[column-1]))
    }
  }
}
```

See the `strings.Fields()` fn? That splits a string based on whitespace characters, as defined in
`unicode.IsSpace()`, and returns a slice of strings. 

Here's the output:

```
$ go run readColumn.go
2
12
2
```

### Creating Summaries

Let's now write an app that adds all the vals of a given column of text with multiple lines.
The column number will be provided as a parameter to the app. And for this, we'll be converting
each value into an integer.

So let's look at `summary.go`:

```go
package main

import (
  "fmt"
  "os"
  "strconv"
  "strings"
)

func main() {
  // define an array of size 3
  var s [3]string

  // populate the array with space-separated data (aka columns)
  s[0] = "1 b 3"
  s[1] = "11 a 1 14 1 1"
  s[2] = "-1 2 -3 -4 -5"

  // grab the arguments passed int
  arguments := os.Args

  // convert the argument passed in to an int
  column, err := strconv.Atoi(arguments[1])

  // exit when the argument can't be converted to an int
  if err != nil {
    fmt.Println("Error reading argument")
    os.Exit(-1)
  }

  // if the column requested is 0, also exit
  if column == 0 {
    fmt.Println("Invalid column")
    os.Exit(1)
  }

  // define a sum var of 0
  sum := 0

  // cycle through the array
  for i := 0; i < len(s); i++ {
    // split the line into "columns"
    data := strings.Fields(s[i])
    // if the data contains the column
    if len(data) >= column {
      // convert to an int
      temp, err := strconv.Atoi(data[column-1])
      if err == nil {
        // add it if valid
        sum = sum + temp
      } else {
        // if the conversion was bad, tell the user
        fmt.Printf("Invalid argument: %s\n", data[column-1])
      }
    } else {
      // if the column isn't in the record, tell the user
      fmt.Println("Invalid column!")
    }
  }
  fmt.Printf("Sum: %d\n", sum)
}
```

Notice that we spend a fair amount of lines performing error checking and handling.

Go ahead and execute the program:

```
$ go run summary.go 0
Invalid column
exit status 1
$ go run summary.go 2
Invalid argument: b
Invalid argument: a
Sum: 2
$ go run summary.go 1
Sum: 11
```

### Finding the Number of Occurrences

A very common programming problem (especially in systems programming) is finding the number of
times that an IP address appears in a log file. So lets use a handy map structure to do this in
`occurrences.go`.

üí° Reminder that a **map** is basically a hash or dictionary in Go. We covered this in
the [Data Structures][map] section of the last chapter.

```go
// occurrences.go
package main

import (
  "fmt"
  "strings"
)

func main() {
  // define an array of size 3 that has strings
  var s [3]string
  s[0] = "1 b 3 1 a a b"
  s[1] = "11 a 1 1 1 1 a a"
  s[2] = "-1 b 1 -4 a 1"

  // create a map (aka hash), where keys are strings and values are ints
  // make(map[key type]value type)
  counts := make(map[string]int)

  // populate the map with data from the array
  for i := 0; i < len(s); i++ {
    // split the string on whitespace for columns
    data := strings.Fields(s[i])
    // range over the data, ignoring the key but grabbing the value
    for _, word := range data {
      // attempt to assign the the counts map
      _, ok := counts[word]
      if ok {
        // if good, increments
        counts[word] = counts[word] + 1
      } else {
        // otherwise, initialize
        counts[word] = 1
      }
    }
  }

  // range over it and output the counts
  for key, _ := range counts {
    fmt.Printf("%s -> %d \n", key, counts[key])
  }
}
```

Let's run it and use the `sort(1)` Unix utility to sort the output:

```
$ go run occurrences.go | sort -n -r -t\  -k3,3
1 -> 8
a -> 6
b -> 3
3 -> 1
11 -> 1
-4 -> 1
-1 -> 1
```

### Find and Replace

The example here will search the provided text for two variations of a given string and replace it
with another string. We'll call it `findReplace.go` and will use some rgex. You'll see
`regexp.Compile()` shine in this case.

```go
// findReplace.go
package main

import (
  "fmt"
  "os"
  "regexp"
)

func main() {
  // create an array of strings of size 3
  var s [3]string
  s[0] = "1 b 3"
  s[1] = "11 a B 14 1 1"
  s[2] = "b 2 -3 B -5"

  // create a regexp.Regexp if the regex is valid
  parse, err := regexp.Compile("[bB]")

  // if it is not valid, output an error and exit
  if err != nil {
    fmt.Printf("Error compiling RE: %s\n", err)
    os.Exit(-1)
  }

  // walk through the s array
  for i := 0; i < len(s); i++ {
    // replace all occurrences of b and B with C
    temp := parse.ReplaceAllString(s[i], "C")
    // output the changed string
    fmt.Println(temp)
  }

  // we can also range through the s array
  for _, val := range s {
    // replace all occurrences of b and B with C
    temp := parse.ReplaceAllString(val, "C")
    // output the changed string
    fmt.Println(temp)
  }
}
```

You could also use a `regexp.MustCompile()` but it does not return an `error` var, it just panics
if the regex can't be parsed. So we use `regexp.Compile()` so we can handle the error, if needed.

Execute it and see the following:

```
1 C 3
11 a C 14 1 1
C 2 -3 C -5
1 C 3
11 a C 14 1 1
C 2 -3 C -5
```

## Reflection

Reflection is an advanced Go feature that lets you dynamically learn the type of an arbitrary object
and garner info about its structure. We used it in the
[Structures section of the last chapter][structures] in `dataStructures.go`. You can see more in the
[`reflect` pkg docs][pkg/reflect]

Let's create `reflection.go` and reflect on some core reflection capabilities.

```go
package main

import (
  "fmt"
  "reflect"
)

func main() {
  // create two custom types: t1 and t2
  type t1 int
  type t2 int

  // create 3 different int variables to reflect on
  x1 := t1(1)
  x2 := t2(1)
  x3 := 1

  // find the concrete values of the 3 different vars
  st1 := reflect.ValueOf(&x1).Elem()
  st2 := reflect.ValueOf(&x2).Elem()
  st3 := reflect.ValueOf(&x3).Elem()

  // print the concrete values
  fmt.Printf("ST1: %v\n", st1)
  fmt.Printf("ST2: %v\n", st2)
  fmt.Printf("ST3: %v\n", st3)

  // detect the types of each of the 3 different vars
  fmt.Printf("X1 Type: %s\n", st1.Type())
  fmt.Printf("X2 Type: %s\n", st2.Type())
  fmt.Printf("X3 Type: %s\n", st3.Type())

  // create another, more complex type
  type aStructure struct {
    X    uint
    Y    float64
    Text string
  }

  // create a var to reflect on
  x4 := aStructure{123, 3.14, "A Structure"}

  // find the concrete values of the new var
  st4 := reflect.ValueOf(&x4).Elem()
  fmt.Printf("ST4: %v\n", st4)

  // detect the type of the new var
  typeOfX4 := st4.Type()

  // print the type of the new var
  fmt.Printf("X4 Type: %s\n", typeOfX4)
  fmt.Printf("The fields of %s are:\n", typeOfX4)

  // cycle through the number of fields in the type and output their type and value
  for i := 0; i < st4.NumField(); i++ {
    fmt.Printf("%d: Field name: %s ", i, typeOfX4.Field(i).Name)
    fmt.Printf("Type: %s ", st4.Field(i).Type())
    fmt.Printf("and Value: %v\n", st4.Field(i).Interface())
  }
}
```

üí° _There exist some laws that govern reflection in Go, but talking about them is beyond the scope 
of this book. What you should remember is that your programs can examine their own structure using 
reflection, which is a very powerful capability._

Run this and get the following output:

```
ST1: 1
ST2: 1
ST3: 1
X1 Type: main.t1
X2 Type: main.t2
X3 Type: int
ST4: {123 3.14 A Structure}
X4 Type: main.aStructure
The fields of main.aStructure are:
0: Field name: X Type: uint and Value: 123
1: Field name: Y Type: float64 and Value: 3.14
2: Field name: Text Type: string and Value: A Structure
```

The `X1` and `X2` lines show that Go does not consider the types of `t1` and `t2` as equal, even tho
they are both aliases of the `int` type.

Despite the fact that Go tries to be a safe programming language, it still lets you handle the
knives and potentially cut yourself by letting you do whatever you like.

### Calling C Code from Go

Go allows you to call C code because, sometimes, that's the only way to get some things done (like
communicating with a hardware device or a db seriver). Regardless, if you find this happening
frequently in your app, then maybe re-evaluate your approach and choice of language.

You should never need this feature, but if you do, you can start by visiting the docs for the
[`cgo` tool][cgo] and the code for [`cgo/gmp/gmp.go`][cgo/gmp].

### Unsafe Code

## Comparing Go to Other Programming Languages

## Analysing Software

### `strace`

### `dtrace`

## Unreachable Code

## Avoiding Common Mistakes ‚ö†Ô∏è

[üîô Writing Programs in Go][previous-chapter]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[üè°][readme]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[Go Packages, Algorithms, and Data Structures üîú][upcoming-chapter]

[readme]: README.md
[previous-chapter]: ch02-writing-programs-in-go.md
[upcoming-chapter]: ch04-go-packages-algorithms-and-data-structures.md
[chapter-6]: ch06-file-input-and-output.md
[chapter-7]: ch07-working-with-system-files.md
[pkg/log]: https://golang.org/pkg/log/
[pkg/log/syslog]: https://golang.org/pkg/log/syslog/
[pkg/regexp]: https://golang.org/pkg/regexp
[pkg/reflect]: https://golang.org/pkg/reflect
[maps]: ch02-writing-programs-in-go.md#maps
[structures]: ch02-writing-programs-in-go.md#structures
[cgo]: https://golang.org/cmd/cgo/
[cgo/gmp]: https://github.com/golang/go/blob/master/misc/cgo/gmp/gmp.go
