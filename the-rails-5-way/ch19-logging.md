[&lt;&lt; Configuring Application Secrets](ch18-configuring-application-secrets.md) | [README](README.md) | [Routing &gt;&gt;](ch20-routing.md)

# Chapter 19. Logging

Most programming contexts in Rails (models, controllers, view templates) have a
`logger` attr, which holds a ref to a logger conforming to the interface of
`Log4r` or the default Ruby 1.8+ `Logger` class.

**Need a `logger`? `Rails.logger` references a logger that you can use anywhere.**

```ruby
Rails.logger.warn 'do not want!'
Rails.logger.debug 'interesting variable value'
Rails.logger.info 'in your logger, giving your info'
```

It's _really_ easy to create a new `Logger` in Ruby. See the following example.

```ruby
require 'logger'
logger = Logger.new STDOUT
logger.warn 'do not want!'
logger.debug 'interesting variable value'
logger.info 'in your logger, giving your info'
```

Typically, messages are added whenever the need arises, using a method related
to the severity of the log message. Standard messages are:

+ debug: use to capture data and app state useful for debugging problems.
  Generally not captured in production logs.
+ info: use to capture information messages, like time-stamping and uncommon
  events that are still within the bounds of good app behavior.
+ warn: use to capture things out of the ordinary that may be worth investigating.
  Sometimes, a logged warning can act as a guard clause in the code to keep a
  client from doing something they weren't supposed to do.
+ error: use to capture info about error conditions that don't require a server
  restart.
+ fatal: worst-case scanrio and the app is now dead and may require manual
  intervention.

## Rails Log Files

The `log` folder of you Rails app holds three log files corresponding to each
of the standard environments. Log files are know to grow very large over time,
so there is a rake task provided for easily clearing them.

To truncate all log files in `log/` to zero bytes, use the following command:

```
rake log:clear
```

The contents of `log/development.log` are very useful while working. Even the
`log/test.log` is useful when requests aren't lining up in your test requests.

All sorts of valuable information is available in the development log. Every time
you make a request, useful info about it shows up in the log. From endpoint called,
to SQL statements run, to layouts rendered.

## Tagged Logging

Log files can contain an extensive amount of info, making tracking down issues or
particular requests difficult. Rails 3.2 introduced the capability to prepend info
to each of your log messages.

To add _tagged_ info to your logs, pass an array of one or many method names that
respond to the `request` object to the `config.log_tags` config setting.

To illustrate, assume you want to track the subdomain that each request is made
from; we can achieve this by setting `config.log_tags` to `[:subdomain]`. When
Rails writes to the log, it will prefix the output of `request.subdomain`, and you
get a log like the following:

```
[some_subdomain] Started GET "/articles" for 127.0.0.1 at 2013-02-01 11:49:09 -0500
```

## Log File Analysis

A number of informal analyses can easily be performed using just the dev log output
and some common sense.

**Performance:** one of the more obvious analyses would be a study of the performance
of your application. Find the queries and rendering sections that are taking a long
time and figure out why.

It's important to realize that the times reported by the logger are not super
accurate. In fact, they're often more wrong than right. However, they do allow
subjective comparisons within the same app.

**SQL queries:** Active Record not behaving as you expect? The fact that SQL
generated by AR is logged can often help you debug problems from complicated
queries.

**Identification of N+1 select problems:** Whenever you are displaying a record
with an associated collection of records, there is a chance that you will have
a so-called N+1 selecte problem, recognizable by series of many `SELECT` statements,
differing only in the primary key.

Too many N+1 queries can bog a system down, so they're worth being aware of,
especially if over a network to a database, introducing latency as well.

N+1 select issues are not the end of the world. A lot of times, all it takes is
proper use of the `includes` method on a particular query to alleviate the problem.

**Separation of Concerns:** A well-designed MVC app follows certain protocols
related to which logical tier does db operations (the model) vs rendering tasks
(the view). In general, you want your controller to cause the loading of all the
data that is going to be needed for rendering from the database. In Rails, it is
accomplished by controller code that queries the model for needed data and maes
that data available to the view.

Database access during rendering is usually considered a bad practice. It violates
proper separation of concerns and is a maintainability nightmare.

However, there are plenty of opportunities for implicit database access during
view rendering to creep into your codebase, encapsulated by the model, and perhaps
triggered by lazy loading of associations. Fragment caching is one place where
that rule can be broken.

**Using Alternate Logging Schemes:** It's easy! Just assign a class compatible
with Ruby's Logger to one of the various `logger` class vars, like
`ActiveRecord::Base.logger`. During a console session, assign a new `Logger`
instance pointing to `STDOUT` to `ActiveRecord::Base.logger` in order to see the
SQL being generated right in your console. [Jamis Buck has a a writeup about this][watching-ar].

### `Rails::Subscriber.colorize_logging`



[&lt;&lt; Configuring Application Secrets](ch18-configuring-application-secrets.md) | [README](README.md) | [Routing &gt;&gt;](ch20-routing.md)

[watching-ar]: http://weblog.jamisbuck.org/2007/1/31/more-on-watching-activerecord
